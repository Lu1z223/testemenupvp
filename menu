// =======================
// Variáveis globais ESP
// =======================
static bool espBox = true;
static bool espLine = true;
static bool teamCheck = true;
static ImVec4 boxColor = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
static ImVec4 lineColor = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);

// Estrutura de exemplo para jogador
struct Player {
    bool isEnemy;
    bool isAlive;
    ImVec2 headPos;
    ImVec2 footPos;
    ImVec2 screenPos;
};

// Função para verificar se está na tela
bool WorldToScreen(const Vec3& worldPos, ImVec2& screenPos) {
    // Você vai precisar substituir pelo seu método de conversão 3D->2D
    // Aqui é só placeholder
    screenPos = ImVec2(worldPos.x, worldPos.y);
    return true; // true = visível
}

// =======================
// Função de desenho ESP
// =======================
void DrawESPForPlayer(const Player& player, ImDrawList* drawList) {
    if (!player.isAlive) return;
    if (teamCheck && !player.isEnemy) return;

    float boxHeight = player.footPos.y - player.headPos.y;
    float boxWidth = boxHeight / 2.0f;

    // Caixa
    if (espBox) {
        drawList->AddRect(
            ImVec2(player.headPos.x - boxWidth / 2, player.headPos.y),
            ImVec2(player.headPos.x + boxWidth / 2, player.footPos.y),
            ImColor(boxColor),
            0.0f,
            0,
            1.0f
        );
    }

    // Linha
    if (espLine) {
        ImVec2 screenCenter = ImVec2(ImGui::GetIO().DisplaySize.x / 2, ImGui::GetIO().DisplaySize.y);
        drawList->AddLine(
            screenCenter,
            player.screenPos,
            ImColor(lineColor),
            1.0f
        );
    }
}

// =======================
// Loop Metal + ImGui
// =======================
- (void)drawInMTKView:(MTKView*)view
{
    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize.x = view.bounds.size.width;
    io.DisplaySize.y = view.bounds.size.height;

    CGFloat framebufferScale = view.window.screen.nativeScale ?: UIScreen.mainScreen.nativeScale;
    io.DisplayFramebufferScale = ImVec2(framebufferScale, framebufferScale);
    io.DeltaTime = 1 / float(view.preferredFramesPerSecond ?: 60);

    id<MTLCommandBuffer> commandBuffer = [self.commandQueue commandBuffer];

    hideRecordTextfield.secureTextEntry = StreamerMode;

    if (MenDeal == true) {
        [self.view setUserInteractionEnabled:YES];
        [self.view.superview setUserInteractionEnabled:YES];
        [menuTouchView setUserInteractionEnabled:YES];
    } else {
        [self.view setUserInteractionEnabled:NO];
        [self.view.superview setUserInteractionEnabled:NO];
        [menuTouchView setUserInteractionEnabled:NO];
    }

    MTLRenderPassDescriptor* renderPassDescriptor = view.currentRenderPassDescriptor;
    if (renderPassDescriptor != nil) {
        id<MTLRenderCommandEncoder> renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
        [renderEncoder pushDebugGroup:@"ImGui Jane"];

        ImGui_ImplMetal_NewFrame(renderPassDescriptor);
        ImGui::NewFrame();
        ImGuiStyle& style = ImGui::GetStyle();
        ImFont* font = ImGui::GetFont();
        font->Scale = 16.f / font->FontSize;

        CGFloat x = (([UIApplication sharedApplication].windows[0].rootViewController.view.frame.size.width) - 340) / 2;
        CGFloat y = (([UIApplication sharedApplication].windows[0].rootViewController.view.frame.size.height) - 250) / 2;

        ImGui::SetNextWindowPos(ImVec2(x, y), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSize(ImVec2(340, 250), ImGuiCond_FirstUseEver);

        if (MenDeal == true) {
            ImGui::SetNextWindowSize(ImVec2(380, 260), ImGuiCond_Always);
            ImGui::Begin("FFH4X KUSH", &MenDeal, ImGuiWindowFlags_NoResize);

            // ------------------------
            // Menu de ESP
            // ------------------------
            if (ImGui::CollapsingHeader("Configurações de ESP", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::Checkbox("ESP Box", &espBox);
                ImGui::Checkbox("ESP Linha", &espLine);
                ImGui::Checkbox("Team Check", &teamCheck);

                ImGui::Text("Cor da Caixa:");
                ImGui::ColorEdit4("##BoxColor", (float*)&boxColor, ImGuiColorEditFlags_NoInputs);

                ImGui::Text("Cor da Linha:");
                ImGui::ColorEdit4("##LineColor", (float*)&lineColor, ImGuiColorEditFlags_NoInputs);
            }

            ImGui::End();
        }

        // =======================
        // Desenhar ESP aqui
        // =======================
        ImDrawList* drawList = ImGui::GetBackgroundDrawList();
        for (auto& player : playersList) { // playersList = vetor dos jogadores
            DrawESPForPlayer(player, drawList);
        }

        ImGui::Render();
        ImGui_ImplMetal_RenderDrawData(ImGui::GetDrawData(), commandBuffer, renderEncoder);

        [renderEncoder popDebugGroup];
        [renderEncoder endEncoding];
        [commandBuffer presentDrawable:view.currentDrawable];
    }

    [commandBuffer commit];
}
